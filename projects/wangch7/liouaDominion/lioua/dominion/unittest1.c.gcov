        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/************************************************************************************
        -:    2:** unittest1.c
        -:    3:** This unit test is designed to test updateCoins function.
        -:    4:** This unit test is build on a past student's test provided & approved by professor.
        -:    5:**
        -:    6:** Include the following lines in makefile:
        -:    7:** unittest1: unittest1.c dominion.o rngs.o
        -:    8:**      gcc -o unittest1 -g  unittest1.c dominion.o rngs.o $(CFLAGS)
        -:    9:*************************************************************************************/
        -:   10:
        -:   11:#include "dominion.h"
        -:   12:#include "dominion_helpers.h"
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <assert.h>
        -:   16:#include "rngs.h"
        -:   17:
        -:   18:// set NOISY_TEST to 0 to remove printfs from output
        -:   19:#define NOISY_TEST 1
        -:   20:#define ASSERTS 1
        -:   21:
        -:   22:int main() 
        -:   23:{
        -:   24:    int i;
        1:   25:    int seed = 1000;
        1:   26:    int numPlayer = 2;
        1:   27:    int maxBonus = 10;
        -:   28:    int p, r, handCount;
        -:   29:    int bonus;
        1:   30:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   31:               , remodel, smithy, village, baron, great_hall};
        -:   32:    struct gameState G;
        1:   33:    int maxHandCount = 5;
        -:   34:    // arrays of all coppers, silvers, and golds
        -:   35:    int coppers[MAX_HAND];
        -:   36:    int silvers[MAX_HAND];
        -:   37:    int golds[MAX_HAND];
       12:   38:    for (i = 0; i < maxHandCount; i++)
        -:   39:    {
        5:   40:        coppers[i] = copper;
        5:   41:        silvers[i] = silver;
        5:   42:        golds[i] = gold;
        5:   43:    }
        -:   44:
        1:   45:    printf ("\n--------------------Start Testing updateCoins()--------------------\n");
        -:   46:
        -:   47:    // function should throw error when bonus is negative. 
        1:   48:    printf("Test player 1 with 5 copper treasure card(s) and -1 bonus.\n");
        1:   49:    bonus = -1;
        1:   50:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   51:    r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
        1:   52:    G.handCount[1] = maxHandCount;                 // set the number of cards on hand
        -:   53:
        1:   54:    memcpy(G.hand[1], coppers, sizeof(int) * MAX_HAND); // set all the cards to copper
        1:   55:    updateCoins(1, &G, bonus);
        -:   56:#if (NOISY_TEST == 1)
        1:   57:                printf("Copper G.coins = %d, expected = N/A because bonus cannot be negative", G.coins);
        -:   58:#endif
        -:   59:
        1:   60:    if(G.coins == maxHandCount * 1 + bonus)
        -:   61:    {
        1:   62:        printf("\nTEST FAILED - Bonus cannot be negative\n");
        1:   63:    }
        -:   64:    else
        -:   65:    {
    #####:   66:        printf("\nTEST SUCCESSFULLY COMPLETED\n");
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:
        6:   71:    for (p = 0; p < numPlayer; p++)
        -:   72:    {
       24:   73:        for (handCount = 1; handCount <= maxHandCount; handCount++)
        -:   74:        {
      240:   75:            for (bonus = 0; bonus <= maxBonus; bonus++)
        -:   76:            {
        -:   77:#if (NOISY_TEST == 1)
      110:   78:                printf("Test player %d with %d treasure card(s) and %d bonus.\n", (p + 1), handCount, bonus);
        -:   79:#endif
      110:   80:                memset(&G, 23, sizeof(struct gameState));   // clear the game state
      110:   81:                r = initializeGame(numPlayer, k, seed, &G); // initialize a new game
      110:   82:                G.handCount[p] = handCount;                 // set the number of cards on hand
        -:   83:
      110:   84:                memcpy(G.hand[p], coppers, sizeof(int) * MAX_HAND); // set all the cards to copper
      110:   85:                updateCoins(p, &G, bonus);
        -:   86:#if (NOISY_TEST == 1)
      110:   87:                printf("Copper G.coins = %d, expected = %d\n", G.coins, handCount * 1 + bonus);
        -:   88:#endif
        -:   89:#if(ASSERTS == 1)
      220:   90:                assert(G.coins == handCount * 1 + bonus); // check if the number of coins is correct
        -:   91:#endif
        -:   92:
      110:   93:                memcpy(G.hand[p], silvers, sizeof(int) * MAX_HAND); // set all the cards to silver
      110:   94:                updateCoins(p, &G, bonus);
        -:   95:#if (NOISY_TEST == 1)
      110:   96:                printf("Silver G.coins = %d, expected = %d\n", G.coins, handCount * 2 + bonus);
        -:   97:#endif
        -:   98:#if(ASSERTS == 1)
      220:   99:                assert(G.coins == handCount * 2 + bonus); // check if the number of coins is correct
        -:  100:#endif
        -:  101:
      110:  102:                memcpy(G.hand[p], golds, sizeof(int) * MAX_HAND); // set all the cards to gold
      110:  103:                updateCoins(p, &G, bonus);
        -:  104:#if (NOISY_TEST == 1)
      110:  105:                printf("Gold G.coins = %d, expected = %d\n", G.coins, handCount * 3 + bonus);
        -:  106:#endif
        -:  107:#if(ASSERTS == 1)
      220:  108:                assert(G.coins == handCount * 3 + bonus); // check if the number of coins is correct
        -:  109:#endif
      110:  110:            }
       10:  111:        }
        2:  112:    }
        -:  113:
        1:  114:    printf("\nTEST SUCCESSFULLY COMPLETED\n");
        1:  115:    printf ("\n--------------------End Testing updateCoins()--------------------\n");
        -:  116:
        1:  117:    return 0;
        -:  118:}
